<html lang="en">
    <head>
        <meta charset="utf-8" />
        <link
        href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
        rel="stylesheet"
      />
        <title>HTML DOM - Drag and drop table column</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <style>
    .apt-top {
      width: 110px;
      height: 50px;
      border-top: 2px solid #444444;
      border-bottom: 2px solid #444444;
      border-left: 2px solid #444444;
      border-right: 2px solid #444444;
    }

    .apt-top-index {
      width: 110px;
      height: 40px;
      border-top: 1px solid #444444;
      border-bottom: 1px solid #444444;
      border-left: 1px solid #444444;
      border-right: 1px solid #444444;
    }

    .apt-top-line-ho {
      width: 110px;
      height: 40px;
      border-top: 1px solid #444444;
      border-bottom: 1px solid #444444;
      border-left: 1px solid #444444;
      border-right: 1px solid #444444;
      background-color: #08797d6b;
    }

    .apt-top-line-floor {
      width: 110px;
      height: 40px;
      border-top: 1px solid #444444;
      border-bottom: 1px solid #444444;
      border-left: 1px solid #444444;
      border-right: 1px solid #444444;
      background-color: #8f8f8f;
    }

    .apt-top-floor {
      width: 110px;
      height: 40px;
      border-top: 1px solid #444444;
      border-bottom: 1px solid #444444;
      border-left: 1px solid #444444;
      border-right: 1px solid #444444;
      background-color: #d5d9db;
    }

    .apt-top-floor-dark {
      width: 110px;
      height: 40px;
      border-top: 1px solid #444444;
      border-bottom: 1px solid #444444;
      border-left: 1px solid #444444;
      border-right: 1px solid #444444;
      background-color: #b3b3b3;
    }

    .apt-make {
      width: 110px;
      height: 40px;
      border-top: 1px solid #444444;
      border-bottom: 1px solid #444444;
      border-left: 1px solid #444444;
      border-right: 1px solid #444444;
      background-color: #b1e0e5;
    }

    .apt-nomake {
      width: 110px;
      height: 40px;
      border-top: 1px solid #444444;
      border-bottom: 1px solid #444444;
      border-left: 1px solid #444444;
      border-right: 1px solid #444444;
      background-color: #f1f1f1;
    }

    .apt-no {
      width: 110px;
      height: 40px;
      border-top: 0px;
      border-bottom: 0px;
      border-left: 0px;
      border-right: 0px;
      background-color: #ffffff;
    }

    .apt-do-work {
      width: 110px;
      height: 40px;
      border-top: 1px solid #444444;
      border-bottom: 1px solid #444444;
      border-left: 1px solid #444444;
      border-right: 1px solid #444444;
      background-color: #397399;
    }

    .apt-do-danger-work {
      width: 110px;
      height: 40px;
      border-top: 1px solid #444444;
      border-bottom: 1px solid #444444;
      border-left: 1px solid #444444;
      border-right: 1px solid #444444;
      background-color: #a72121;
    }

    .apt-basement-park {
      width: 110px;
      height: 40px;
      border-top: 1px solid #444444;
      border-bottom: 1px solid #444444;
      background-color: #e7dbb8;
    }

    table td.highlighted {
      background-color: rgb(252, 252, 252);
    }
    .draggable {
      cursor: move;
      user-select: none;
    }
    .placeholder {
      background-color: #edf2f7;
      border: 2px dashed #cbd5e0;
    }
    .clone-list {
      border-left: 1px solid #ccc;
      border-top: 1px solid #ccc;
      display: flex;
    }
    .clone-table {
      border-collapse: collapse;
      border: none;
    }
    .clone-table th,
    .clone-table td {
      border: 1px solid #ccc;
      border-left: none;
      border-top: none;
      padding: 0.5rem;
    }
    .dragging {
      background: #fff;
      border-left: 1px solid #ccc;
      border-top: 1px solid #ccc;
      z-index: 999;
    }
        </style>
    </head>

        <script
        src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"
        integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ=="
        crossorigin="anonymous"
        referrerpolicy="no-referrer"
      ></script>
        <script>

function initAPT() {
      var MAX_E = $("#stair").val();
      var MAX_F = $("#floor").val();
      var MAX_NO = $("#ho").val();
      var MAX_B = $("#basement").val();
      var dong = $("#dong").val();
      $("#inputBox").remove();
      var appendArea = $("#table");
      var floorFlag =
        MAX_F; /* 현재 그리고 있는 층 (한 층을 다 그린뒤 1씩 감소, 0보다 작아질경우 -1 후 절대값 변환) */
      var floor =
        floorFlag +
        "F"; /* 현재 그리고 있는 층 (지상/지하 표기), 시작은 지상층부터라는 가정 (이후 지하층으로만 구성된 현장이있을경우 Foreach문에 if문으로 변경할 것) */
      var exitFlag = 0; /* 각 층별 계단 Cell을 그릴때 기준점이 될 변수 ( 한칸을 그릴때마다 1씩 증가 / 최대값(MAX_E) 도달시 0으로 초기화 ) */
      var hoFlag = 0; /* 각 층별 호 Cell을 그릴때 기준점이 될 변수, 0일경우 층수를 그린다 ( 한칸을 그릴때마다 1씩 증가 / 최대값(MAX_F) 도달시 0으로 초기화 ) */

      var innerData = "";

      innerData +=
        '<thead><tr><th class="apt-top-index" data-type="number">구분</th>';
      

      /* 해당 동의 호 인덱스 그리기 */
      for (var i = 1; i <= MAX_NO; i++) {
        innerData += '<th class="apt-top-line-ho">' + i + "호</th>";
      }
      /* 해당 동의 계단 인덱스 그리기 */
      for (var i = 1; i <= MAX_E; i++) {
        innerData += '<th class="apt-top-line-floor">계단' + i + "</th>";
      }

      innerData += "</tr>";
      innerData += "</thead>";
      innerData += '<tbody>';
      for (var i = 0; i < Number(MAX_F) + Number(MAX_B); i++) {
        innerData += '<tr><td class="apt-top-floor">' + floor + "</td>";

        for (var j = 1; j <= MAX_NO; j++) {
          innerData +=
            '<td id="' +
            floor +
            "_" +
            exitFlag +
            '" class="apt-make"><b style="display:none">' +
            floor +
            "</b></td>";
        }

        for (var k = 1; k <= MAX_E; k++) {
          innerData +=
            '<td id="' +
            exitFlag +
            "_" +
            exitFlag +
            '" class="apt-top-floor-dark">&nbsp;&nbsp;</td>';
        }

        innerData += "</tr>";
        floorFlag--;

        if (floorFlag > 0) {
          floor = floorFlag + "F";
        } else if (floorFlag <= 0) {
          floor = "B" + Math.abs(floorFlag - 1);
        }
      }

      innerData += "</tbody>";
      innerData +=
        '<br><input type="button" value="저장" onclick="complte()" />';

      appendArea.append(innerData);
      document.addEventListener('DOMContentLoaded',  initFunction());
    }
    function initFunction() {


      var isMouseDown = false;
      /* 마우스를 누른 상태 */
      $("#table td").mousedown(function () {
          isMouseDown = true;
          $(this).toggleClass("highlighted");
          return false;
        })
        .mouseover(function () {
          if (isMouseDown) {
            $(this).toggleClass("highlighted");
          }
        })
        .bind("selectstart", function () {
          return false;
        });
        /* 마우스를 뗀 상태 */
      $(document).mouseup(function () {
        isMouseDown = false;
      });

                const table = document.getElementById('table');

                let draggingEle;
                let draggingColumnIndex;
                let placeholder;
                let list;
                let isDraggingStarted = false;

                // The current position of mouse relative to the dragging element
                let x = 0;
                let y = 0;

                // Swap two nodes
                const swap = function (nodeA, nodeB) {
                    const parentA = nodeA.parentNode;
                    const siblingA = nodeA.nextSibling === nodeB ? nodeA : nodeA.nextSibling;

                    // Move `nodeA` to before the `nodeB`
                    nodeB.parentNode.insertBefore(nodeA, nodeB);

                    // Move `nodeB` to before the sibling of `nodeA`
                    parentA.insertBefore(nodeB, siblingA);
                };

                // Check if `nodeA` is on the left of `nodeB`
                const isOnLeft = function (nodeA, nodeB) {
                    // Get the bounding rectangle of nodes
                    const rectA = nodeA.getBoundingClientRect();
                    const rectB = nodeB.getBoundingClientRect();

                    return rectA.left + rectA.width / 2 < rectB.left + rectB.width / 2;
                };

                const cloneTable = function () {
                    const rect = table.getBoundingClientRect();

                    list = document.createElement('div');
                    list.classList.add('clone-list');
                    list.style.position = 'absolute';
                    list.style.left = `${rect.left}px`;
                    list.style.top = `${rect.top}px`;
                    table.parentNode.insertBefore(list, table);

                    // Hide the original table
                    table.style.visibility = 'hidden';

                    // Get all cells
                    const originalCells = [].slice.call(table.querySelectorAll('tbody td'));

                    const originalHeaderCells = [].slice.call(table.querySelectorAll('th'));
                    const numColumns = originalHeaderCells.length;

                    // Loop through the header cells
                    originalHeaderCells.forEach(function (headerCell, headerIndex) {
                        const width = parseInt(window.getComputedStyle(headerCell).width);

                        // Create a new table from given row
                        const item = document.createElement('div');
                        item.classList.add('draggable');

                        const newTable = document.createElement('table');
                        newTable.setAttribute('class', 'clone-table');
                        newTable.style.width = `${width}px`;

                        // Header
                        const th = headerCell.cloneNode(true);
                        let newRow = document.createElement('tr');
                        newRow.appendChild(th);
                        newTable.appendChild(newRow);

                        const cells = originalCells.filter(function (c, idx) {
                            return (idx - headerIndex) % numColumns === 0;
                        });
                        cells.forEach(function (cell) {
                            const newCell = cell.cloneNode(true);
                            newCell.style.width = `${width}px`;
                            newRow = document.createElement('tr');
                            newRow.appendChild(newCell);
                            newTable.appendChild(newRow);
                        });

                        item.appendChild(newTable);
                        list.appendChild(item);
                    });
                };

                const mouseDownHandler = function (e) {
                    draggingColumnIndex = [].slice.call(table.querySelectorAll('th')).indexOf(e.target);

                    // Determine the mouse position
                    x = e.clientX - e.target.offsetLeft;
                    y = e.clientY - e.target.offsetTop;

                    // Attach the listeners to `document`
                    document.addEventListener('mousemove', mouseMoveHandler);
                    document.addEventListener('mouseup', mouseUpHandler);
                };

                const mouseMoveHandler = function (e) {
                    if (!isDraggingStarted) {
                        isDraggingStarted = true;

                        cloneTable();

                        draggingEle = [].slice.call(list.children)[draggingColumnIndex];
                        draggingEle.classList.add('dragging');

                        // Let the placeholder take the height of dragging element
                        // So the next element won't move to the left or right
                        // to fill the dragging element space
                        placeholder = document.createElement('div');
                        placeholder.classList.add('placeholder');
                        draggingEle.parentNode.insertBefore(placeholder, draggingEle.nextSibling);
                        placeholder.style.width = `${draggingEle.offsetWidth}px`;
                    }

                    // Set position for dragging element
                    draggingEle.style.position = 'absolute';
                    draggingEle.style.top = `${draggingEle.offsetTop + e.clientY - y}px`;
                    draggingEle.style.left = `${draggingEle.offsetLeft + e.clientX - x}px`;

                    // Reassign the position of mouse
                    x = e.clientX;
                    y = e.clientY;

                    // The current order
                    // prevEle
                    // draggingEle
                    // placeholder
                    // nextEle
                    const prevEle = draggingEle.previousElementSibling;
                    const nextEle = placeholder.nextElementSibling;

                    // // The dragging element is above the previous element
                    // // User moves the dragging element to the left
                    if (prevEle && isOnLeft(draggingEle, prevEle)) {
                        // The current order    -> The new order
                        // prevEle              -> placeholder
                        // draggingEle          -> draggingEle
                        // placeholder          -> prevEle
                        swap(placeholder, draggingEle);
                        swap(placeholder, prevEle);
                        return;
                    }

                    // The dragging element is below the next element
                    // User moves the dragging element to the bottom
                    if (nextEle && isOnLeft(nextEle, draggingEle)) {
                        // The current order    -> The new order
                        // draggingEle          -> nextEle
                        // placeholder          -> placeholder
                        // nextEle              -> draggingEle
                        swap(nextEle, placeholder);
                        swap(nextEle, draggingEle);
                    }
                };

                const mouseUpHandler = function () {
                    // // Remove the placeholder
                    placeholder && placeholder.parentNode.removeChild(placeholder);

                    draggingEle.classList.remove('dragging');
                    draggingEle.style.removeProperty('top');
                    draggingEle.style.removeProperty('left');
                    draggingEle.style.removeProperty('position');

                    // Get the end index
                    const endColumnIndex = [].slice.call(list.children).indexOf(draggingEle);

                    isDraggingStarted = false;

                    // Remove the `list` element
                    list.parentNode.removeChild(list);

                    // Move the dragged column to `endColumnIndex`
                    table.querySelectorAll('tr').forEach(function (row) {
                        const cells = [].slice.call(row.querySelectorAll('th, td'));
                        draggingColumnIndex > endColumnIndex
                            ? cells[endColumnIndex].parentNode.insertBefore(
                                  cells[draggingColumnIndex],
                                  cells[endColumnIndex]
                              )
                            : cells[endColumnIndex].parentNode.insertBefore(
                                  cells[draggingColumnIndex],
                                  cells[endColumnIndex].nextSibling
                              );
                    });

                    // Bring back the table
                    table.style.removeProperty('visibility');

                    // Remove the handlers of `mousemove` and `mouseup`
                    document.removeEventListener('mousemove', mouseMoveHandler);
                    document.removeEventListener('mouseup', mouseUpHandler);
                };

                table.querySelectorAll('th').forEach(function (headerCell) {
                    headerCell.classList.add('draggable');
                    headerCell.addEventListener('mousedown', mouseDownHandler);
                });
            };
        </script>
            <body>
              <div id="inputBox" style="margin-left: 20px; margin-top: 20px; border: 1px solid #000; width: 300px; padding: 10px;" >
              동 이름 &nbsp;&nbsp;&nbsp;&nbsp;: <input id="dong" type="text" /> <br />
              <!-- 이미 있는 동인지 확인할것 -->
              최고 층 수 : <input id="floor" type="text" /> <br />
              지하 층 수 : <input id="basement" type="text" /> <br />
              최대 호 수 : <input id="ho" type="text" /> <br />
              계단 개수 &nbsp;: <input id="stair" type="text" /> <br />
              <input type="button" value="만들기" onclick="initAPT()" />
            </div>
            <table id="table" class="table"></table>

    </body>
</html>